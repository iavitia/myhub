# Exam Ref 70-761 Querying Data with Transact-SQL

Transact-SQL is the main language used to manage and manipulate data in Microsoft SQL Server and Azure SQL Database.

## part 1

### Logical query processing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T-SQL has both logical and physical sides to it. The logical side is the conceptual interpretation of the query that explains what the correct result of the query is. The physical side is the processing of the query by the database engine. Physical processing must produce the result defined by logical query processing. The database engine can optimize the query by rearranging steps from logical query processing or remove steps altogether, but only as long as the result remains the one defined by logical query processing. Because of this, it's important not to draw any performance-related conclusions from what you are reviewing about logical query processing. since it only defines the correctness of the query. 

Syntax for writing SELECT statements are ordered as such:
```sql
SELECT  
FROM
WHERE
GROUP BY
HAVING
ORDER BY
```
Logical query processing orders the clauses as such:
```sql
FROM  
WHERE
GROUP BY
HAVING
SELECT
ORDER BY
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each phase operates on one or more tables as inputs and returns a virtual table as output. The output table of one phase is considered the input to the next phase. This is in accord with operations on relations that yield a relation. If an ORDER BY is specified, the result isn’t relational. This means that you can’t operate on such result with an outer query because an outer query expects a relation as input. The output of the ORDER BY phase isn’t relational because it has a guaranteed order. The result of this phase is what standard SQL calls a cursor.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since the WHERE clause comes before the SELECT clause in logical query processing, it can not refer to an alias defined in the SELECT clause. However, the ORDER BY clause is the first and only clause that is allowed to refer to column aliases defined in the SELECT clause. In addition, alias's created during the SELECT phase are not visible to other expressions that appear in the same SELECT list. This is because expressions that appear in the same logical query-processing step are treated as a set, and a set has no order. T-SQL evaluates all expressions that appear in the same phase in an all-at-once manner. For example, this code will not work:
```sql
SELECT YEAR(hiredate) AS yearhired, yearhired - 1 AS prevyear
FROM HR.Employees;
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It’s important to understand the difference between WHERE and HAVING. The WHERE clause is evaluated before rows are grouped, and therefore is evaluated per row. The HAVING clause is evaluated after rows are grouped, and therefore is evaluated per group.

### Select
The FROM clause is the first clause to be evaluated logically in a SELECT query. The FROM clause has two main roles:
* It’s the clause where you indicate the tables that you want to query.
* It’s the clause where you can apply table operators like joins to input tables.

The SELECT clause of a query has two main roles: 
* It evaluates expressions that define the attributes in the query’s result, assigning them with aliases if needed. 
* Using a DISTINCT clause, you can eliminate duplicate rows in the result if needed.

Using AS is recommended for defining aliases because it's both standard and is the most readable. There are two main uses for intentional attribute aliasing. One is renaming when you need the result attribute to be named differently than the source attribute. Another use is to assign a name to an attribute that results from an expression that would otherwise be unnamed. In this example, employeeid is intentional and the full name concatenation will return with no attribute name:

```sql
SELECT empid, firstname + N' ' + lastname 
FROM HR.Employees;
```
#### LIKE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The LIKE is used to filter character string data (regular or unicode) based on pattern matching. It also supports wildcards that you can use in your patterns. Wildcards that you can ise in your LIKE pattern include:
|Wildcard | Meaning | Example |
|-------- | ------- | ------- |
| % (percent sign) | Any string including an empty on | ‘D%’: string starting with D |
| _ (underscore) | A single character | ‘_D%’: string where second character is D |

| Wildcard           | Meaning                           | Example                                         |
|--------------------|-----------------------------------|-------------------------------------------------|
| % (percent sign)   | Any string including an empty one | ‘D%’: string starting with D                    |
| _ (underscore)     | A single character                | ‘_D%’: string where second character is D       |
| [<character list>] | A single character from a list    | ‘[AC]%’: string where first character is A or C |
| [<character range>] | A single character from a range    | ‘[0-9]%’: string where first character is a digit|
| [^<character list or range>] | A single character that is not in the list or range    | ‘[^0-9]%’: string where first character is not a digit|

#### Best practices
* It is considered a best practice to always explicitly indicate the schema name in the FROM clause. This practice can prevent you from ending up with a schema name that you did not intend to use, and can also remove the cost involved in the implicit resolution process, although this cost is minor.
* T-SQL supports using an asterisk(*) to list all attributes from the input table; however, it is considered a bad practice and you should always explicitly list the attributes that you need.

### Union

### Union all

### Joins
#### Inner
#### Left
#### Right
#### Full outer
#### Cross
#### Nulls

### Functions and aggregate data
#### scaral valued
#### table valued
#### Deterministic
#### Non-deterministic
#### Built-in aggregate
#### Arithmetic
#### Date-related
#### System functions

### Modifying data
#### Insert
#### Update
#### Delete
#### Output

## part 2 
### Subqueries

### Apply
#### Cross Apply
#### Outer Apply

### Table experssions
#### recursive table expressions
### Temporary tables

### Grouping sets
### Cube
### Pivot
#### Nulls
### Unpivot

### Json

### XML


## Program databases by using T-SQL